
=head1 NAME

Hustle::Table - Fast dynamic dispatching to subroutines

=head1 SYNOPSIS

  use Hustle::Table;

  #1. Create a new object
  my $table=Hustle::Table->new;

  #2. Add entries which contain:
  #	matcher:	required. The matcher  (ie regex, string, number) to test with
  #	sub:		required. The sub to call when matcher is 'true' when testing input
  #	label:		optional. For identification
  #	count:		optional. Used as priority when adding (larger number=> higher priority)
  #Can either be a array ref or hash ref

  $table->add(
  	{match=>qr/regex (match)/, sub=>sub{ #can access regex capture }}, #entry as a hash ref
	[qr/another/,sub{},"my label",10],			#entry as array ref
	[undef,sub {},"default",undef]				#undef matcher is default match all
  );

  #3. Prepare a dispatcher:
  # 	A dispatcher is sub reference, which is called directly with in put to match
  #     Different types, caching and other processing options.

  my $dispatch=$table->prepare_dispatcher(type=>"online", cache=>{}, reorder=>1); # or loop, loop_cached, dynamic_cached


  #4. Dispatch from input
  $dispatch->("thing to match","optional", "arguemnts");	# any number of arguments passsed to sub


  #Training is also possible please see below
  

=head1 Description

This module provides a small class to construct a dispatch table and build a dispatcher for it. All interactions are done via the object/class methods so no exports are defined.

It supports straightforard optimisation of the dispatch table and also utilises a optional cache to squeeze even more performance out.

Notable features include:

 
=over 

=item Uses buildin perl features  (regex, given/when, smartmatch)

=item Captures in regex avaiable in dispatched subs

=item Cached prematching (optional)

=item Basic hit count and optimising (optional)

=item Fall through/catch all matching

=back


=head2 How it works

The dispatch table is essentially a list of at least one entry which maps a matcher to a subroutine to call when the matcher successfully matches the input.

Conceptually the list looped over, applying the matcher to the input until a match is found. In the case no match being found, a default catch all sub is called.
 
In practice it isn't a loop but generated code in a possibly optimised order that processes the list.



=head1 Adding Entries

Entrys are added in either annonamous hash or array format, using the C<add> method.
Array entries must contain four elements, in the order of:
	
	[$matcher,$sub,$label,$count]

and hashes only need to specifiy the matcher and sub pairs

	{matcher=>$matcher, sub=>$sub, label=>$label, count=>$count}

In either case, C<$sub> is the only field/item that must be defined. It must also be a CODE reference.

=head1 Caching and Cache control

A hash lookup is much quicker than repeated conditional testing and a simple hash cache is used to prevent repeated matching of previously seen input.

If the the same input is presented again, it is found in the hash, and not through 'searching' the table. If found, the input is then subject to the same matcher to ensure any regex grouping gets applied.

The return code of the dispatched sub is important. It is used to indicate if key should be removed from the cache. Any 'true' value returned will means the input, as a key to the cache, is to be removed from the cache. Any 'false' value indicates the input is to remain in the cache or be added if it doesn't exist.




=head1 Entry structure

=over 

=item matcher

C<$matcher> can be anything that smartmatching can handle. However the focus on this module is on strings
and regular expressions

	"match exaclty this stirng"
	qr|match and capture (this|that)|

When C<$matcher> is a regex, any capturing is accessable in the target C<sub>.

=item sub

The C<$sub> has access to any capture groups used in the matcher (if applicable). It is also passed all arguments, including the input, unmodified that where used to call the dispatcher sub.

ie
	$dispatcher->("my input","optional", "arguments","to", "dispatched", "sub");

The return value of the sub indicates if the input just matched is to be reomved from the cache. 

=item label

C<$label> is a user defined item to allow identification of the entry. This is useful for saving/loading from configuration files etc.

=item count

C<$count> This is a dual purpose attributes. When adding entries to the list, it is used as a priority. Higher numeric values are a higher priority. The list is sorted in decenting order of priority, meaning the highest priority is the first element in the list.

During running of the dispatch, this is a tally recording how many times,the entry has been matched. This information can be then used to as a priority later and the list reorded.

=back

=head2 The Default matcher

Each list has a default matcher that will unconditionally match the input. This entry is specified by using 'undef' as the matcher when adding an entry. When set this way only the array format can be used.

To make it more explicit, the it can also be changed via the C<set_default> method. 

The default subroutine of the 'default' entry does nothing.

=head1 Performance

The concept is to perform less searching to find the dispatch vector. However the type of input does play an important role in determining the best way perform the search.

For example a uniformly distributed input will not gain benefits from reording the entries in the list.

On the other hand when the distributing becomes 'centred', the reording of the table can greatly improve the search time.

My simple benchmarking script shows around 1M dispatches/s for non cached and almost 2M dispatches/s for cached


=over

=item Uniformly distributed input


For uniformly distributed input, the fastest method is to use the dynamically generated non caching 
method. Resorting or optimising search order has no real effect as the probablilty of each case is equal. In this case the method with the least run time overhead will perform the best.

Caching can have a detrimental effect as it take cpu time to consult the cache

=item 




=head1 Comparison to other modules

There a couple of other dispatching modules on CPAN.
Notably L<Smart::Dispatch> has a nice syntax and the ability to return values instead of just executing subOther than also using the 'smartmatching' of a C<given> block, to perform the matching, it has a much difference approach to manipulating a dispatch table. It seems to have much flexibility compared to this module.

Speed of matching and dispatching together with the ability to use capturing in your regular expressing matchers is where Hustle::Table shows strength



=head1 AUTHOR

Ruben Westerberg, E<lt>drclaw@mac.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2021 by Ruben Westerberg

MIT Licensed

=cut
